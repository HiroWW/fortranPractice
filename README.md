## Fortran90/95 memo

### 疑問点

- コンパイルエラーが不親切。
  - Unclassifiable statement at (1)が何も教えてくれない
  - has no IMPLICIT typeはuseをしていないから（そう教えてくれ）
- implicit noneとuse文の順序など、順番が結構めんどう
- 添え字を変更したいのってどういう局面？絶対面倒になるんだから全部デフォルトの1を使うべきでは。

### 登場した組み込み関数

- mod(a,p) ! aをpで割ったあまり
- dble(n) ! 引数を倍精度実数型変数に変換
- acos(i) !三角関数
- dot_product(u, v) !内積
  - ベクトルの大きさを取得する際にも有用
- minval(a),maxval(a), sum(a) ! 配列の要素の最大値最小値和
- minloc(a),maxloc(a) ! 配列の最大最小値の位置を配列で返す
  - 一次元であっても配列なので、代入したいなら a = minloc(a, 1) としてスカラ化すること
- y(:) = matmul(a, x) ! 行列、ベクトルの積計算
  - y(:, :) = matmul(a, b) ! 行列同士の積ならこう
- 

### 登場した組み込みサブルーチン

- call random_number(x) ! xに0~1のランダムな数を生成して代入
- call cpu_time(t1) ! 処理系の時間tを取得 t2とt1を取って差分出力で処理の実行時間が分かる

### 1章 basics

- implicit none宣言は必ず行う
  - これをしないと定義していない変数を使用していてもコンパイルが通ってしまう

- 特に理由のない限り実数型変数はすべて倍精度実数型変数として宣言するのがよい
  - real(8)のこと
  - 単精度実数型だと計算精度が不足することが多い
  - 数値を代入するときは89d0のように末尾にd0を付ける
- doループはステップ値を変更できる
  - do i = 1, 5, 2なら1,3,5の順にiが代入される

- ファイル入出力は
  - open(fi,file="filename.d")
  - read(fi, *) n
  - write(fi, *) x, y, z
  - ここでfiは入出力ファイル番号
    - 5,6は標準入出力に割当てられているので使用しない方がいい
- 状態変数stat
  - integer is
  - allocate( a(n,n) , stat = is)
  - if (is /= 0) stop "cannot allocate !"
  - statの結果をisに代入 成功すれば0が入る


３－５節（４６ｐまで）

### 2章 array

- 配列の宣言はreal(8) u(2)
- 中身の定義の仕方はu(1:2) = (/ 1.2d0, 3.4d0 /)
- 配列外参照をエラーで教えてくれるコンパイルオプションgfortran -fbounds-check main.f90
  - 僕のコンパイラだとデフォで警告してくれる
- 配列に対してもスカラ変数同様に組み込み演算が可能
  - ib(1:4) = 10 + 2 * a(1:4)
  - b(1:4) = sqrt( abs( a(1:4) ) )
  - 配列の要素ごとの演算であり、数学的な行列の四則演算とは意味が異なることに注意
- 部分配列を用いた配列の外部ファイル入出力
  - open(20, file = "input2.d") 
  - read(20, *)  b(1:4)
- i行j列の二次元配列はreal(8) a(2, 3)で定義される
- parameter属性を付けると定数化されてプログラムの実行開始から終了まで不変となる
  - integer, paramter :: n = 10
- 割付配列を用いると配列サイズをプログラム中で変更可能
  - real(8), allocatable :: u(:) !一次元配列の宣言
  - integer, allocatable :: im(:, :) !二次元配列の宣言
  - allocate ( u(n), im(n,m) ) !割付
  - deallocate (u, im) ! 割付解除　これ以降新たなサイズで変更可能
- 配列は近い者同士でアクセスした方が実行時間が少なく、効率的な処理が行える
  - 左にある添え字を先に動かすようにループを組むべし
  - 多重ループでは左側にある添え字を動かすループの内側に入れる（そのほうが先に実行される）
- 添え字三つ組み
  - x(-2:2:2)は三つ目の要素がストライドである。
  - x = 1, 2, 3, 4, 5とすれば1, 3, 5が出力される
- 部分配列は配列内要素に対して、doループを使わずに簡潔にアクセスできるのが強み
  - あとは3 * 3行列の右下2要素を取りたい場合にはia(2:3, 2:3)的なことが出来て便利！

### 3章 module sub program

- return文でsubroutineを途中で抜け出せる
  - id (a == b) return
- routineごとに局所変数がリセットされず、引き継がれるようにするには
  - integer, save :: ic = 3
  - とする。ただ、初期値をつけて宣言した時点で自動でsave属性がつくので、これは可読性向上のためのコツ
  - リセットしたいなら宣言と定義をべつの行で行うこと。
- 仮引数にはintent属性をつけることが推奨される
  - 代入してはいけない値に代入をしたり返り値を設定しなかったときのコンパイルエラーが出せる
  - real(8), intent(in) :: a !呼び出し側で値が確定し、副プログラム中で値変更を許さない
  - real(8), intent(out) :: a ! 必ず副プログラム中で値が代入され、値を保持してメインプログラムに戻る
  - real(8), intent(inout) :: a ! ↑のどっちもできる。
- function Name(仮引数) result(返り値)
  - 返すのは単一の変数のみ
  - call がいらず、プログラムが簡潔に書ける。
  - 組み込み関数も同じような実装である。
- サブルーチンの引数に配列を取りたい場合
  - 引数に寸法も取って、形状明示仮配列を使う
  - 引数に寸法を取らず、::で定義しておいてsizeで寸法を取得してdoループなどの処理をする形状引き継ぎ配列
    - 外部副プログラムではインターフェースモジュールを用意する必要あり
- 配列要素を実引数にして配列の一部を仮配列として受け取る
  - printc(x, m)
  - call printc(a(1,1), 3)
  - とすると、a配列の1列目の3要素がxに渡される　謎仕様だ～～～　ポインタ渡し的な部分と似ている...
- 実引数として未割り付けの割付配列を渡したい場合は、仮引数の宣言にallocatable属性を付ける。
  - ​	real(8), allocatabe, intent(out) :: a(:, :) ! こういうこと
- グローバル変数モジュール内では変数にsave属性を付ける
  - モジュールの処理が終わると変数のメモリが解放されて値が不安定になるため
- 外部から参照できる変数はprivate,publicを用いて明示的に宣言する
  - implicit none // private // (変数の宣言) // public a, b, c
  - 「外部から参照できない」とはつまり、module内の変数がサブルーチンの局所変数と同じ扱いになる、ということである
- private,publicが使えなくてもonly句によって呼び出し側のプログラムから参照の制限をすることも可能
  - use sample_mod, only : a, b ! a, bのみが参照可能となった

### 4章 external subprogram

- module ifmod // interface // function nor... // 仮引数と返り値の宣言 // end function nor... // end interface // end module ifmod
- IFmoduleを用意することで外部サブプログラムで使えるようになる機能
  - 仮引数と実引数の整合がコンパイル時にチェックされる
  - 未割り付けの割付配列を実引数とすることが出来る
  - 仮配列として形状引き継ぎ配列を利用できる
  - 配列を返す外部関数を作成できる
- 外部サブプログラムに利用により、モジュール間の複雑な依存関係が解消される
- 外部サブプログラム内で別の外部サブプログラムを使いたい場合は、使いたいプログラムのみをonly句で使用宣言すればいい
  - use interface_mod, only : print_mat
  - call print_mat　!これならコンパイルエラーにならない
- コンパイル順はifmodule.f90が最初で外部副プログラムとmainは順番を問わない

### 5章 new features of external subprogram

